# Gateway Integration

## CRITICAL: Analysis-First Approach

**DO NOT START IMPLEMENTATION** until you have completed ALL mandatory analysis steps.

⚠️ **FAILURE CONDITIONS - Integration will be rejected if:**
- You skip reading ARCHITECTURE.md sections with the Read tool
- You skip reading NESTJS_BEST_PRACTICES.md with the Read tool
- You don't verify all modules are imported
- Security configurations are not properly applied
- Health check endpoints are not implemented

---

## DATA SOURCES (Must Read Before Implementation)

### Primary Analysis Files (in output/ folder)
| File | Purpose | What to Extract |
|------|---------|-----------------|
| `output/analysis/legacy_analysis.json` | PHP function analysis | Global configurations |
| `output/analysis/routes.json` | Route mappings | All routes requiring integration |
| `output/analysis/architecture_security_db.json` | Security issues | CORS, headers, rate limiting requirements |
| `output/analysis/extracted_services.json` | Microservices list | Services requiring ClientProxy |

### Architecture Reference (MUST READ WITH Read TOOL)
| File | Section | Line Range | Required Extractions |
|------|---------|------------|---------------------|
| `ARCHITECTURE.md` | **Section 3: Nx Structure** | Lines 150-300 | App and lib organization |
| `ARCHITECTURE.md` | **Section 5: Communication Patterns** | Lines 400-550 | Microservice connections |
| `ARCHITECTURE.md` | **Section 10: Infrastructure** | Lines 1100-1200 | Health checks, observability |
| `ARCHITECTURE.md` | **Section 12: Security** | Lines 1248-1340 | CORS, Helmet, rate limiting |
| `NESTJS_BEST_PRACTICES.md` | **Full file** | All | Module imports, guards, filters |

### Module Locations
| Directory | Purpose |
|-----------|---------|
| `apps/gateway/src/modules/` | All gateway modules to integrate |
| `apps/gateway/src/app/` | AppModule location |
| `libs/` | Shared libraries to import |

---

## PHASE 1: MANDATORY ANALYSIS (Must Complete Before Writing Code)

### Step 1.1: List All Gateway Modules

Execute this command to list all modules requiring integration:

```bash
echo "=== GATEWAY MODULES ==="
ls -la apps/gateway/src/modules/

echo ""
echo "=== MODULE DETAILS ==="
for dir in apps/gateway/src/modules/*/; do
    module_name=$(basename "$dir")
    module_file="$dir${module_name}.module.ts"
    if [ -f "$module_file" ]; then
        echo "Module: $module_name"
        grep -E "^export class" "$module_file" | head -1
    fi
done
```

### Step 1.2: Check Current AppModule State

```bash
echo "=== CURRENT APP MODULE ==="
cat apps/gateway/src/app/app.module.ts
```

### Step 1.3: List Extracted Microservices

```bash
if [ -f "output/analysis/extracted_services.json" ]; then
    echo "=== EXTRACTED MICROSERVICES ==="
    cat output/analysis/extracted_services.json | python3 -c "
import json, sys
data = json.load(sys.stdin)

for service in data.get('services', []):
    name = service.get('name', 'N/A')
    transport = service.get('transport', 'TCP')
    print(f'Service: {name}')
    print(f'  Transport: {transport}')
    print(f'  Host: {service.get(\"host\", \"localhost\")}')
    print(f'  Port: {service.get(\"port\", \"N/A\")}')
    print()
"
else
    echo "No extracted services file found."
    echo "Check ARCHITECTURE.md Section 5 for microservice connections."
fi
```

### Step 1.4: Read Security Issues

**IMPORTANT:** Security issues affect gateway configuration.

```bash
cat output/analysis/architecture_security_db.json | python3 -c "
import json, sys
data = json.load(sys.stdin)

# Show ALL security types relevant to gateway
relevant_types = ['xss', 'sql_injection', 'command_injection', 'weak_crypto', 'insecure_function']

print('=== SECURITY ISSUES TO ADDRESS ===')
print()
for issue_type in relevant_types:
    details = data.get('security', {}).get('by_type', {}).get(issue_type, {})
    affected = details.get('affected_files', [])
    if affected:
        print(f'{issue_type.upper()} ({len(affected)} files):')
        for f in affected[:3]:
            print(f'  - {f}')
        if len(affected) > 3:
            print(f'  ... and {len(affected) - 3} more')
        if details.get('examples'):
            ex = details['examples'][0]
            print(f'  Remediation: {ex.get(\"recommendation\", \"N/A\")}')
        print()
"
```

### Step 1.5: READ ARCHITECTURE.md Section 3 - Nx Structure (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 150
  limit: 150
```

**Extract and document:**
- [ ] All apps in the monorepo
- [ ] All shared libraries
- [ ] Import paths for each library

### Step 1.6: READ ARCHITECTURE.md Section 5 - Communication Patterns (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 400
  limit: 150
```

**Extract and document:**
- [ ] Microservice connection details (host, port, transport)
- [ ] ClientProxy registration patterns
- [ ] Message patterns for each service

### Step 1.7: READ ARCHITECTURE.md Section 10 - Infrastructure (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 1100
  limit: 100
```

**Extract and document:**
- [ ] Health check endpoint requirements (`/health`, `/ready`)
- [ ] Database health check configuration
- [ ] Redis health check configuration
- [ ] Observability requirements

### Step 1.8: READ ARCHITECTURE.md Section 12 - Security (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 1248
  limit: 95
```

**Extract and document:**
- [ ] CORS configuration requirements
- [ ] Helmet security headers
- [ ] Rate limiting configuration
- [ ] Global exception filter requirements

### Step 1.9: READ NESTJS_BEST_PRACTICES.md (MANDATORY)

**YOU MUST USE THE Read TOOL** to read the relevant section:

```
Read tool parameters:
  file_path: output/analysis/NESTJS_BEST_PRACTICES.md
  offset: 1
  limit: 300
```

**Extract patterns for:**
- [ ] Module import patterns
- [ ] Global filter registration
- [ ] Guard configuration
- [ ] Interceptor setup

### Step 1.10: Create Integration Checklist

Based on ALL the analysis above, create a complete integration checklist:

| Component | Status | Configuration Required |
|-----------|--------|----------------------|
| ConfigModule | Pending | isGlobal: true, envFilePath |
| DatabaseModule | Pending | TypeORM connection |
| CacheModule | Pending | Redis connection |
| AuthModule | Pending | JWT configuration |
| CategoriesModule | Pending | - |
| ProductsModule | Pending | - |
| SearchModule | Pending | - |
| ContentModule | Pending | - |
| SEO ClientProxy | Pending | TCP host:port |
| Payment ClientProxy | Pending | TCP host:port |
| Health Module | Pending | Terminus configuration |
| AllExceptionsFilter | Pending | Global filter |
| CORS | Pending | Origins, methods |
| Helmet | Pending | Security headers |
| Rate Limiting | Pending | Throttler configuration |

---

## PHASE 2: ARCHITECTURE CONTEXT

### Gateway Structure

```
apps/gateway/src/
├── app/
│   ├── app.module.ts          # Main module - all imports here
│   ├── app.controller.ts      # Base routes (/, /health, /ready)
│   └── app.service.ts
├── modules/
│   ├── config/
│   ├── auth/
│   ├── categories/
│   ├── products/
│   ├── search/
│   ├── content/
│   └── ...
├── filters/
│   └── all-exceptions.filter.ts
├── guards/
│   └── ... (if global guards needed)
└── main.ts                    # Bootstrap with global configs
```

### main.ts Configuration Requirements

```typescript
// Required configurations in main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // CORS
  app.enableCors({
    origin: configService.get('CORS_ORIGINS').split(','),
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    credentials: true,
  });

  // Helmet
  app.use(helmet());

  // Global prefix (if needed)
  app.setGlobalPrefix('api', { exclude: ['health', 'ready'] });

  // Global filters
  app.useGlobalFilters(new AllExceptionsFilter());

  // Validation pipe
  app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));

  await app.listen(configService.get('PORT') || 3000);
}
```

### Security Requirements (from ARCHITECTURE.md Section 12)

| Requirement | How to Implement |
|-------------|------------------|
| CORS | Configure allowed origins via env variable |
| Helmet | Use `helmet` middleware for security headers |
| Rate limiting | Use `@nestjs/throttler` with configurable limits |
| Exception filter | Create `AllExceptionsFilter` for consistent error responses |
| Validation | Global `ValidationPipe` with whitelist and transform |

---

## PHASE 3: IMPLEMENTATION

**Only proceed after PHASE 1 and PHASE 2 are complete.**

### Target Location
- Main app: `apps/gateway/src/app/`
- Filters: `apps/gateway/src/filters/`
- Project: `m-action-nestjs`

### Implementation Tasks

#### 1. Import All Modules into AppModule

```typescript
@Module({
  imports: [
    // Configuration
    ConfigModule.forRoot({ isGlobal: true }),

    // Database
    DatabaseModule,

    // Cache
    CacheModule.register({
      isGlobal: true,
      store: redisStore,
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT),
    }),

    // Microservice clients (if applicable)
    ClientsModule.register([
      {
        name: 'SEO_SERVICE',
        transport: Transport.TCP,
        options: { host: process.env.SEO_HOST, port: parseInt(process.env.SEO_PORT) },
      },
      {
        name: 'PAYMENT_SERVICE',
        transport: Transport.TCP,
        options: { host: process.env.PAYMENT_HOST, port: parseInt(process.env.PAYMENT_PORT) },
      },
    ]),

    // Health
    TerminusModule,

    // Rate limiting
    ThrottlerModule.forRoot({ ttl: 60, limit: 100 }),

    // Feature modules
    AuthModule,
    CategoriesModule,
    ProductsModule,
    SearchModule,
    ContentModule,
    // ... all other modules
  ],
  controllers: [AppController, HealthController],
  providers: [
    AppService,
    { provide: APP_FILTER, useClass: AllExceptionsFilter },
    { provide: APP_GUARD, useClass: ThrottlerGuard },
  ],
})
export class AppModule {}
```

#### 2. Create AllExceptionsFilter

```typescript
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      message = exception.message;
    }

    // Log full error internally
    console.error(exception);

    // Return generic response to client
    response.status(status).json({
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
```

#### 3. Create Health Controller

```typescript
@Controller()
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private db: TypeOrmHealthIndicator,
  ) {}

  @Get('health')
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.db.pingCheck('database'),
    ]);
  }

  @Get('ready')
  @HealthCheck()
  ready() {
    return this.health.check([
      () => this.db.pingCheck('database'),
      // Add more readiness checks as needed
    ]);
  }
}
```

#### 4. Configure main.ts

Apply all global configurations as documented in Phase 2.

---

## PHASE 4: VERIFICATION

### Pre-Implementation Checklist

**Analysis Steps (ALL REQUIRED):**
- [ ] Step 1.1: Listed all gateway modules
- [ ] Step 1.2: Checked current AppModule state
- [ ] Step 1.3: Listed extracted microservices
- [ ] Step 1.4: Executed security issues extraction
- [ ] **Step 1.5: READ ARCHITECTURE.md Section 3** (Nx structure)
- [ ] **Step 1.6: READ ARCHITECTURE.md Section 5** (communication patterns)
- [ ] **Step 1.7: READ ARCHITECTURE.md Section 10** (infrastructure)
- [ ] **Step 1.8: READ ARCHITECTURE.md Section 12** (security)
- [ ] **Step 1.9: READ NESTJS_BEST_PRACTICES.md**
- [ ] Step 1.10: Created complete integration checklist

**Understanding Verified:**
- [ ] All modules to import identified
- [ ] Microservice connections documented
- [ ] Security configuration requirements understood
- [ ] Health check requirements documented

### Post-Implementation Checklist

- [ ] All modules imported into AppModule
- [ ] ClientProxy configured for microservices (if applicable)
- [ ] AllExceptionsFilter created and registered globally
- [ ] Security configurations applied:
  - [ ] CORS configured in main.ts
  - [ ] Helmet middleware applied
  - [ ] Rate limiting with ThrottlerModule
  - [ ] ValidationPipe globally enabled
- [ ] Health endpoints implemented:
  - [ ] `/health` endpoint working
  - [ ] `/ready` endpoint working
  - [ ] Database health check configured
- [ ] All tests pass
- [ ] Build succeeds without errors
- [ ] No lint errors

### Validation Commands
```bash
# Run tests
nx test gateway --coverage

# Build
nx build gateway

# Lint
nx lint gateway

# Test health endpoints (after starting app)
# nx serve gateway
# curl http://localhost:3000/health
# curl http://localhost:3000/ready
```

---

## COMPLETION

When ALL verifications pass:
```
SERVICE_COMPLETE
```

If stuck after analysis:
```
NEEDS_REVIEW: [describe the blocking issue]
```
