# Payment Client Library

## CRITICAL: Analysis-First Approach

**DO NOT START IMPLEMENTATION** until you have completed ALL mandatory analysis steps.

⚠️ **FAILURE CONDITIONS - Library creation will be rejected if:**
- You skip reading ARCHITECTURE.md sections with the Read tool
- You skip reading NESTJS_BEST_PRACTICES.md with the Read tool
- You don't document all service patterns from ARCHITECTURE.md
- Security requirements are not applied to client methods
- You don't read extracted service contracts (if available)

---

## DATA SOURCES (Must Read Before Implementation)

### Primary Analysis Files (in output/ folder)
| File | Purpose | What to Extract |
|------|---------|-----------------|
| `output/analysis/legacy_analysis.json` | PHP function analysis | Payment-related functions |
| `output/analysis/architecture_security_db.json` | Security issues | XSS, SQL injection, weak crypto |
| `output/services/payment-api/contracts/service_contract.json` | Service contract | API endpoints, message patterns |
| `output/services/payment-api/analysis/service_context.json` | LLM context | Full service context for implementation |

### Architecture Reference (MUST READ WITH Read TOOL)
| File | Section | Line Range | Required Extractions |
|------|---------|------------|---------------------|
| `ARCHITECTURE.md` | **Section 5: Communication Patterns** | Lines 400-550 | Payment service patterns |
| `ARCHITECTURE.md` | **Section 12: Security** | Lines 1248-1340 | crypto.randomBytes, input validation |
| `NESTJS_BEST_PRACTICES.md` | **Full file** | All | HttpModule patterns, error handling |

### Extracted Service Data (if available)
| File | Purpose |
|------|---------|
| `output/services/payment-api/` | Extracted payment service analysis |
| `output/services/payment-api/contracts/call_contract.json` | Input/output contracts |
| `output/services/payment-api/shared-lib/` | Shared DTOs for payment service |

---

## PHASE 1: MANDATORY ANALYSIS (Must Complete Before Writing Code)

### Step 1.1: Check for Extracted Payment Service

Execute this command to check if payment service was extracted:

```bash
if [ -d "output/services/payment-api" ]; then
    echo "=== EXTRACTED PAYMENT SERVICE FOUND ==="
    ls -la output/services/payment-api/
    echo ""
    echo "=== SERVICE CONTEXT ==="
    cat output/services/payment-api/analysis/service_context.json | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(f'Service: {data.get(\"service_name\", \"N/A\")}')
print(f'Endpoints: {len(data.get(\"endpoints\", []))}')
print(f'Patterns: {len(data.get(\"message_patterns\", []))}')
for ep in data.get('endpoints', [])[:5]:
    print(f'  - {ep.get(\"method\")} {ep.get(\"path\")}')
"
else
    echo "No extracted payment service found."
    echo "Using ARCHITECTURE.md patterns only."
fi
```

### Step 1.2: Read Payment-Related PHP Functions

```bash
cat output/analysis/legacy_analysis.json | python3 -c "
import json, sys
data = json.load(sys.stdin)

# Target payment-related PHP files
target_files = ['payment', 'checkout', 'wallet', 'credit', 'amex', 'transaction']

all_files = data.get('all_files', [])
found_any = False
for f in all_files:
    path = f.get('path', '').lower()
    if any(t in path for t in target_files):
        found_any = True
        print(f'\\n=== {path.split(\"m-action/\")[-1]} ===')
        print(f'Lines: {f.get(\"total_lines\")}')
        for fn in f.get('functions', []):
            params = ', '.join(fn.get('params', []))
            db = '[DB]' if fn.get('calls_db') else ''
            print(f'  - {fn.get(\"name\")}({params}) {db}')

if not found_any:
    print('WARNING: No payment-related PHP files found.')
    print('Check ARCHITECTURE.md Section 5 for payment service patterns.')
"
```

### Step 1.3: Read Security Issues

**IMPORTANT:** Security issues affect all modules, especially payment handling.

```bash
cat output/analysis/architecture_security_db.json | python3 -c "
import json, sys
data = json.load(sys.stdin)

# Show ALL security types relevant to payment services
relevant_types = ['xss', 'sql_injection', 'command_injection', 'weak_crypto', 'insecure_function']

print('=== SECURITY ISSUES TO ADDRESS ===')
print()
for issue_type in relevant_types:
    details = data.get('security', {}).get('by_type', {}).get(issue_type, {})
    affected = details.get('affected_files', [])
    if affected:
        print(f'{issue_type.upper()} ({len(affected)} files):')
        for f in affected[:3]:
            print(f'  - {f}')
        if len(affected) > 3:
            print(f'  ... and {len(affected) - 3} more')
        if details.get('examples'):
            ex = details['examples'][0]
            print(f'  Remediation: {ex.get(\"recommendation\", \"N/A\")}')
        print()
"
```

### Step 1.4: READ ARCHITECTURE.md Section 5 - Communication Patterns (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 400
  limit: 150
```

**Extract and document for payment client:**
- [ ] All payment service message patterns
- [ ] Command names (e.g., `payment.credit-card.charge`)
- [ ] Request/response DTOs
- [ ] Transport protocol (TCP, HTTP, gRPC)

### Step 1.5: READ ARCHITECTURE.md Section 12 - Security (MANDATORY)

**YOU MUST USE THE Read TOOL** to read this section:

```
Read tool parameters:
  file_path: output/analysis/ARCHITECTURE.md
  offset: 1248
  limit: 95
```

**Extract and document:**
- [ ] Use `crypto.randomBytes()` for tokens (NOT Math.random())
- [ ] Secure handling of payment data
- [ ] Input validation for all payment requests
- [ ] Error handling without exposing sensitive data

### Step 1.6: READ NESTJS_BEST_PRACTICES.md (MANDATORY)

**YOU MUST USE THE Read TOOL** to read the relevant section:

```
Read tool parameters:
  file_path: output/analysis/NESTJS_BEST_PRACTICES.md
  offset: 1
  limit: 300
```

**Extract patterns for:**
- [ ] HttpModule configuration
- [ ] Service injection patterns
- [ ] Error handling and retries
- [ ] DTO validation
- [ ] Module exports

### Step 1.7: Read Service Contracts (MANDATORY if extracted service exists)

**YOU MUST USE THE Read TOOL:**

```
Read tool parameters:
  file_path: output/services/payment-api/contracts/service_contract.json
```

**Extract:**
- [ ] All API endpoints
- [ ] Message patterns
- [ ] Request/response types

### Step 1.8: Create Service Pattern Mapping Table

Based on ALL the analysis above, create a complete mapping table:

| Pattern Name | Command | Request DTO | Response DTO | Security Requirements |
|-------------|---------|-------------|--------------|----------------------|
| CREDIT_CARD_CHARGE | `payment.credit-card.charge` | ChargeCreditCardDto | ChargeResponseDto | Validate card data, secure logging |
| CREDIT_CARD_REFUND | `payment.credit-card.refund` | RefundCreditCardDto | RefundResponseDto | Validate transaction ID |
| WALLET_CHARGE | `payment.wallet.charge` | ChargeWalletDto | ChargeResponseDto | Validate user, amount |
| WALLET_BALANCE | `payment.wallet.balance` | GetBalanceDto | BalanceResponseDto | Auth required |
| AMEX_CHARGE | `payment.amex.charge` | ChargeAmexDto | ChargeResponseDto | Amex-specific validation |
| APPLE_PAY_CHARGE | `payment.apple-pay.charge` | ChargeApplePayDto | ChargeResponseDto | Token validation |
| GROUPS_CREATE | `payment.groups.create` | CreateGroupDto | GroupResponseDto | Admin auth |
| GROUPS_UPDATE | `payment.groups.update` | UpdateGroupDto | GroupResponseDto | Admin auth |
| TRANSACTION_GET | `payment.transaction.get` | GetTransactionDto | TransactionResponseDto | Auth required |
| TRANSACTION_SYNC | `payment.transaction.sync` | SyncTransactionDto | SyncResponseDto | System-level auth |

---

## PHASE 2: ARCHITECTURE CONTEXT

### Service Patterns to Implement (from ARCHITECTURE.md Section 5)

```typescript
PAYMENT_PATTERNS = {
  CREDIT_CARD_CHARGE: { cmd: 'payment.credit-card.charge' },
  CREDIT_CARD_REFUND: { cmd: 'payment.credit-card.refund' },
  WALLET_CHARGE: { cmd: 'payment.wallet.charge' },
  WALLET_BALANCE: { cmd: 'payment.wallet.balance' },
  AMEX_CHARGE: { cmd: 'payment.amex.charge' },
  APPLE_PAY_CHARGE: { cmd: 'payment.apple-pay.charge' },
  GROUPS_CREATE: { cmd: 'payment.groups.create' },
  GROUPS_UPDATE: { cmd: 'payment.groups.update' },
  TRANSACTION_GET: { cmd: 'payment.transaction.get' },
  TRANSACTION_SYNC: { cmd: 'payment.transaction.sync' },
}
```

### Client Library Structure

```
libs/payment-client/
├── src/
│   ├── lib/
│   │   ├── payment-client.module.ts
│   │   ├── payment-client.service.ts
│   │   ├── payment-client.service.spec.ts
│   │   ├── dto/
│   │   │   ├── charge-credit-card.dto.ts
│   │   │   ├── refund-credit-card.dto.ts
│   │   │   ├── charge-wallet.dto.ts
│   │   │   ├── wallet-balance.dto.ts
│   │   │   ├── charge-amex.dto.ts
│   │   │   ├── charge-apple-pay.dto.ts
│   │   │   ├── create-group.dto.ts
│   │   │   ├── update-group.dto.ts
│   │   │   ├── get-transaction.dto.ts
│   │   │   ├── sync-transaction.dto.ts
│   │   │   └── index.ts
│   │   └── interfaces/
│   │       ├── payment-response.interface.ts
│   │       └── index.ts
│   └── index.ts
├── jest.config.ts
├── tsconfig.json
├── tsconfig.lib.json
├── tsconfig.spec.json
└── project.json
```

### Security Requirements (from ARCHITECTURE.md Section 12)

| Requirement | How to Implement |
|-------------|------------------|
| No weak crypto | Use `crypto.randomBytes()` for any tokens |
| Input validation | Use `class-validator` decorators on ALL request DTOs |
| Secure logging | Never log full card numbers, mask sensitive data |
| Error handling | Return generic errors to clients, log details internally |
| Retry with backoff | Use exponential backoff for transient failures |

---

## PHASE 3: IMPLEMENTATION

**Only proceed after PHASE 1 and PHASE 2 are complete.**

### Target Location
- Library: `libs/payment-client/`
- Project: `m-action-nestjs`

### Implementation Requirements

1. **Create Nx Library**
   ```bash
   nx generate @nx/nest:library payment-client --directory=libs/payment-client --buildable
   ```

2. **PaymentClientModule**: Export `PaymentClientService` and `HttpModule`

3. **PaymentClientService Methods**:
   - `chargeCreditCard(dto: ChargeCreditCardDto): Promise<ChargeResponseDto>`
   - `refundCreditCard(dto: RefundCreditCardDto): Promise<RefundResponseDto>`
   - `chargeWallet(dto: ChargeWalletDto): Promise<ChargeResponseDto>`
   - `getWalletBalance(dto: GetBalanceDto): Promise<BalanceResponseDto>`
   - `chargeAmex(dto: ChargeAmexDto): Promise<ChargeResponseDto>`
   - `chargeApplePay(dto: ChargeApplePayDto): Promise<ChargeResponseDto>`
   - `createGroup(dto: CreateGroupDto): Promise<GroupResponseDto>`
   - `updateGroup(dto: UpdateGroupDto): Promise<GroupResponseDto>`
   - `getTransaction(dto: GetTransactionDto): Promise<TransactionResponseDto>`
   - `syncTransaction(dto: SyncTransactionDto): Promise<SyncResponseDto>`

4. **Error Handling**:
   - Implement retry logic with exponential backoff
   - Circuit breaker pattern for service unavailability
   - Custom `PaymentException` for payment-specific errors

5. **DTOs**: All request DTOs must have `class-validator` decorators

6. **Tests**: Unit tests with >80% coverage, mock HTTP responses

---

## PHASE 4: VERIFICATION

### Pre-Implementation Checklist

**Analysis Steps (ALL REQUIRED):**
- [ ] Step 1.1: Checked for extracted payment service
- [ ] Step 1.2: Executed payment function extraction
- [ ] Step 1.3: Executed security issues extraction
- [ ] **Step 1.4: READ ARCHITECTURE.md Section 5** (communication patterns)
- [ ] **Step 1.5: READ ARCHITECTURE.md Section 12** (security)
- [ ] **Step 1.6: READ NESTJS_BEST_PRACTICES.md**
- [ ] **Step 1.7: READ service contracts** (if extracted service exists)
- [ ] Step 1.8: Created complete pattern mapping table

**Understanding Verified:**
- [ ] All payment patterns identified
- [ ] Transport protocol confirmed (HTTP/TCP)
- [ ] Security requirements documented
- [ ] NestJS HttpModule patterns understood

### Post-Implementation Checklist

- [ ] Library created at `libs/payment-client/`
- [ ] All 10 payment methods implemented
- [ ] DTOs have proper validation (`class-validator`)
- [ ] Security requirements applied:
  - [ ] Input validation on all DTOs
  - [ ] Sensitive data masking in logs
  - [ ] Generic error messages to clients
- [ ] Retry logic with exponential backoff
- [ ] Tests pass with >80% coverage

### Validation Commands
```bash
nx test payment-client --coverage
nx build payment-client
nx lint payment-client
```

---

## COMPLETION

When ALL verifications pass:
```
SERVICE_COMPLETE
```

If stuck after analysis:
```
NEEDS_REVIEW: [describe the blocking issue]
```
